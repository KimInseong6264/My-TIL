# 2025-12-18~20 TIL

## 오늘 배운 내용
- 상태에 따른 이동 로직 구현
    - 상태 전환 조건을 확인하기 어려워, 시각적 표현(Debug.DrawRay 활용)
    - 타일맵 콜라이더를 뚫고 추적(콜라이더 세팅 확인)
- 몬스터 공격 판정 추가
    - 공격시, 이펙트 생성 및 제거
    - 히트 박스 판정이 되지 않는 문제 해결(플레이어 RigidBody 추가)
    - 돌진 공격시, 맵을 뚫고 나가버리는 문제 해결
- 몬스터 데이터 SO화
    - SO 데이터 제작 후, A스타 경로탐색 오류(SO에서 타일맵 세팅시, transform값을 제대로 받아올 수 없음)
- 애니메이션 연결
- A스타 알고리즘 문제 해결
    - 잦은 호출로 셧다운 문제
- MVP 패턴 변환
    - MVC 패턴 -> MVP 패턴 형태로 리펙토링

## 느낀 점

#### 1) A스타 알고리즘 무서운 놈이었다....

A스타 알고리즘으로 경로탐색을 무사히 마쳤다. 하지만 문제가 너무 많았다... <br>
생각 이상으로 **알고리즘의 연산량이 상당히 무거웠다는 것**을 느꼈다. <br>
개인 작업을 할 때에는 인지를 못했는데, 프로토타입을 위해 서로 결과물을 합쳤을 때 문제가 발생했다. <br>

****로딩 시간부터가 몬스터를 추가하면 엄청 길어지는 문제****가 있었고, 더 최악의 문제는 <br>
런타임 중에 **몬스터와 상호작용하는 과정에 셧다운**이 되는 치명적인 문제가 발생해버렸다. <br>
사실 길찾기 알고리즘 자체가 연산이 많이 되고 코드 작성을 하면서도 **시간복잡도를 따져봤을 때 O(n²)일** 것 같았다. <br>
즉, 굉장히 무거운 연산이라는 것을 알 수 있다.

결과부터 말하자면 로딩 시간과 셧다운 문제는 A스타 최적화와 잦은 호출이 각각 문제였다. <br>
A스타 구현을 하고나서 리펙토링을 하지 않았는데, 예외처리를 해줘야 하는 1가지가 있었는데 <br>
**같은 F값의 노드를 비교할 때는 G값이 더 작은 것을 선택**해줘야 진정한 A스타이고 성능적 이득이 있는데 <br>
이 부분을 반영하지 못했다. 그래서 쓸데없는 연산이 추가되었고 몬스터가 6마리 정도였음에도 로딩이 길어지게 되었다. <br>
거기에 이런 무거운 연산을 플레이어를 추적하게 되면 **실시간으로 경로 탐색을 진행**하니, 연산량이 급격히 늘어난 것이다.

결국 **리펙토링을 거쳐서 최적화**를 하니, 로딩 시간은 단축할 수 있었다. 하지만 플레이어를 추적할 때에는 A스타 사용을 포기하기로 했다. <br>
사실 단순히 특정 타겟을 향해 이동하는 로직은 A스타를 사용할 필요 없이 **Translate로 해결**할 수 있었다. <br>
어차피 LOS 기능을 함께 도입할 예정이기에 벽을 뚫는 경우도 없었고 생각한 대로 동작을 했다.

A스타를 고치면서 **PriorityQueue**를 사용하면 **시간복잡도를 O(n log n)으로 낮출 수 있다**고 했지만 <br>
지금은 프로토타입이기도 하고, PriorityQueue는 내장된 기능이 아니라 직접 코드로 구현해야 하다보니 <br>
시간이 더 걸릴 것 같아서 **추후에 리펙토링 해 볼 계획**이다.

그리고 오늘 깨달은 것 중에 하나는 **굳이 어려운 것에만 집착하지 말자**는 것이다. <br>
사실 셧다운 문제에 부딪혔을 때, 이동 방식을 바꿔야할까 고민을 하기는 했다. 굳이 경로 탐색으로 추적할 이유가 없기 때문이다. <br>
하지만 이왕 만들어본 A스타를 최대한 활용해보고 싶었기에 도입을 해서 사용하고 싶었다. <br>
물론 이런 문제들을 접했기에 A스타를 사용하는 것도 신중해질 필요가 있고, 최적화도 해볼 수 있었다는 것은 좋았다. <br>
하지만 결국 개발자로서는 **게임의 성능 최적화가 가장 1순위가 되어야 하고** 오늘 같은 경우에는 **최적화 측면에서 Translate로 바꾸는 것**이 <br>
올바른 선택이 되겠다는 것을 느꼈다. 앞으로의 게임 개발에서도 이 부분은 명심하도록 해야겠다. <br>

##### 절대 겉멋 들지 말고! 초심을 유지하면서 최선의 코드를 사용하는 개발자가 되도록 하자!!

#### 2) 콜라이더 지옥에 빠졌었다..

이제껏 LayerMask를 제대로 사용해본 적이 없었는데, 이번 기회에 Layer에 대해 많이 공부했다. <br>
일단 Layer를 사용하면서 헷갈렸던 게 **Tag랑 비교해서 왜 Layer를 사용하는지가 궁금했다.** <br>
핵심은 상호작용하는 것의 **범위를 분류해주는 것은 Layer**가, 명확하게 딱 **1개의 정보를 특정하고 싶을 때는 Tag**를 사용한다. <br>

Layer는 여러 개를 동시에 특정해줄 수 있는 특징이 있었다. <br>
이를 활용한다면 레이캐스트가 특정 Layer를 가진 오브젝트들만 인식하게 하는 게 가능해진다. <br>
이번 프로젝트에 경우 Ray가 Player와 Wall 타일만을 분류하면 되기에 그 외의 충돌체들은 맞았다는 검사도 하지 않아도 된다. <br>
이 경우 **layerMask로 Player와 Wall만 지정을 해준다면 Ray는 이 2개의 레이어를 제외하고는 모두 그냥 통과**하게 되어 있다. <br>
그리고 부딪힌 정보가 Player인지, Wall인지에 따라 다르게 상호작용을 처리할 수 있다. <br>

여기서 Tag를 활용해서 정보를 분류해서 처리할 수는 있겠지만, 이미 Layer가 지정된 상황이기에 굳이 Tag까지 사용할 필요가 없다. <br>
즉, **대부분의 상황에서 Layer로도 분류가 가능**하다는 것이고 오늘을 기점으로 Tag보다는 Layer를 더 애용하게 될 것 같다. <br>

그런데 Layer는 Tag보다 사용법이 조금 더 복잡해서 익숙해지는데 시간이 좀 걸리긴 했다. <br>
Tag와 달리 Layer는 **int값으로 관리**가 되는데, 더 중요한 것은 **이진수로 관리**가 되고 있었다는 것이다. <br>
그래서 그냥 NameToLayer를 사용하니까 레이캐스트가 충돌을 제대로 감지하지 못하는 문제가 발생했다. <br>
**레이캐스트에 사용되는 인자값은 이진수를 사용해야했고, GetMask로 값**을 불러왔어야 했다. <br>
그래서 한참을 헤매다가 이진수로 레이캐스트를 입력해서 해결했다. <br>

웃긴 건, 각 **gameObject의 layer는 일반 십진수의 값을 사용**한다는 것이고 이 때 **NameToLayer를 사용**하는 것이었다.
이것때문에 고생을 좀 했지만, 그래도 Layer에 대해 제대로 공부한 것 같아서 기분은 좋았던 것 같다.

이 레이캐스트 문제를 해결하니, 산 넘어 산이라고 공격판정에서 또 다른 충돌 판정 문제가 생겼다. <br>
사실 이번에도 **RigidBody**를 플레이어에게 달아주지 않았던 게 문제였는데 **제발 좀!!!!! RigidBody도 같이 달아주자!** <br>
그런데 진짜 문제는 몬스터의 공격 이펙트 판정에서 발생한 것인데, **몬스터의 돌진 공격이 벽을 뚫어버리는 문제**였다. <br>

이게 해결이 잘 안 된 것이 몬스터까지 콜라이더를 달고 동작을 하면 부자연스러워지거나, 물리적으로 오류가 날 것 같았다. <br>
그래서 선택한 방법이 레이캐스트였고, 이 **레이캐스트를 공격시에 발사해서 벽에 닿으면 이동을 멈추는 로직으로 구성**했다. <br>
이 방법이 최적화 측면에서도 합리적인 방법이기도 하고, 모션도 자연스럽게 멈출 수 있었다. <br>
그리고 이를 시각적으로 명확히 확인할 수 있는 방법이 기즈모 말고도 **Debug.DrawLine과 Debug.DrawRay**였다.

이 2가지 Debug 방식을 사용하니까 시각적으로 레이캐스트의 방향을 알 수 있었고 테스트하기에도 좋았다. <br>
이런 시각적인 방법으로 테스트를 하는 것도 앞으로 자주자주 사용할 것 같아서 이 부분도 잘 공부된 것 같다.


#### 3) 드디어 MVP를 써먹게 되는 구나~

이전 개인 프로젝트에서는 MVC 패턴을 구현하는데 힘을 썼다면 이번에는 MVP 패턴을 구현해봤다. <br>
이번 사전합반 프로젝트를 하면서 상태 패턴과 MVC 패턴을 사용한 적이 있었기에 손쉽게 패턴들을 구현했다. <br>
확실히 일일히 구글링을 하거나 공부한 거 찾아보는 시간이 없이 머릿속에서 그려지는대로 코드를 작성했다. <br>
각 **Model, Controller, View의 역할들도 구분이 잘 되고 머리로 정리**가 나름 잘 되어 있는 것 같다고 느꼈다.

MVP 패턴 자체는 MVC를 기반으로 해석을 하니까 그렇게 어렵지 않았다. <br>
**View에만 MonoBehaivour**을 달아서 동작을 하고 **Model과 Presenter는 new로 생성**을 한다. <br>
(이 부분은 저번 개인 프로젝트를 하면서 new의 개념을 확실히 이해한 거라 막히는 게 없었다.) <br>
그리고 **Model은 데이터와 데이터 변동 메서드 / View는 시각적인 정보(UI, 애니메이션)를 조작하는 메서드(관련 데이터값은 없음)** <br>
이것들을 가지고 **Presenter는 이 메서드들이 언제 호출 될 지를 결정하는 역할**을 한다고 생각하면 된다.

MVC에서는 Model과 View의 상호작용이 조금은 존재하지만 MVP에서는 이를 Presenter가 중계하는 구조여서 <br>
**게임을 제작하는 입장에서는 MVC보다는 MVP가 좋다**고 느껴졌다. <br>
Controller와 View의 역할이 명확하지 않은 것 같았던 것이, 둘 다 MonoBehaviour을 상속하고 있기에 컴포넌트화가 되어 있고 <br>
그렇기에 라이프 사이클 각자 사용이 가능하다는 것부터 서로가 메서드를 호출하게 되는 구조가 뭔가 객체지향의 느낌이 죽는 느낌이 있었다. <br>
그래서 이번에 **MVP 패턴으로 구현을 하면서 각자의 기능들이 독립적으로 분류**가 되는 것 같아서 추후 **유지보수에 더 강점**을 갖는 것 같았다.

그리고 확실히 저번 개인 프로젝트에서 상태 패턴과 MVC 패턴을 연습한 것이 정말 도움이 많이 되는 것 같다. <br>
(비록 개인 프로젝트는 만들고 싶은 목표에 한참 못 미치는 완성도였다는 게 아쉽지만...) <br>
상태 패턴과 MVC를 결합해서 사용할 때는 복잡하게만 느껴졌지만 이번에 또 한 번 구현을 해보니까 <br>
**복잡하지 않도록 서로 최대한 독립되게 코드를 작성**하게 되었고, 그 결과로 **리펙토링을 하더라도 손이 많이 가지 않았다.** <br>
매번 느끼지만 **연습과 경험이 결국 좋은 방향으로만 나를 성장 시키는 것 같다**고 느껴졌다.

항상 팀 프로젝트를 진행할 때마다 많은 것을 배우고 느끼는 것 같다. <br>
**나는 협업이 좀 더 나에게 잘 맞는 거 같다**고 생각이 든다. 거기에 팀원들이 있어서 의지도 할 수 있기도 해서인지 <br>
에러와 버그를 마주하더라도 개인 프로젝트할 때보다 훨씬 심적 부담은 적어지고, 책임감은 커지는 이상한 상태가 된다. <br>
정말 팀원들이 있어서 고맙고 또 더 보탬이 되고 싶다.

---

## 내용정리 블로그 링크






