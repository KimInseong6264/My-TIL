# 2025-12-14~17 TIL

## 오늘 배운 내용
- A스타 알고리즘 경로 탐색 기능 구현
- 상태 패턴(순찰, 추적, 탐색) 기능 구현
- 레이캐스트를 활용한 LOS 기능 구현
    - 레이캐스트 구현을 위한 기즈모 활용

## 느낀 점

#### 1) A스타 알고리즘 최종 완성!!

이틀에 걸쳐서 A스타 알고리즘을 완성해냈다. 원리적으로는 13일에 이해를 끝냈지만 이를 직접 코드로 구현하는 것이 여간 힘들었다. <br>
먼저 **타일맵의 데이터를 기반으로 노드를 만들어내는 것**부터가 난관이었다. <br>
정수화 된 Vector2 값에 해당하는 노드를 만들어내고, 이 노드가 **이동 가능한 타일인지 판단하는 코드**를 만드는 것이 시작인데, <br>
이 작업이 머릿속으로 잘 그려지지가 않았고 예상보다 많은 시간을 허비하게 되었다.

이후에는 **OpenList**와 **ClosedList**를 만들어서 이웃 노드들을 만들어 OpenList에 담아두고, 거기서 **가장 F값(G + H)이 작은 것**을 꺼낸다. <br>
그리고 그 값으로 **이동**을 한 다음, 이동한 노드에서의 **이웃노드들을 만들어서 OpenList에 담는다.** <br>
그러고 나면 OpenList에는 처음에 넣었던 이웃노드들(이동한 노드 제외)과 새롭게 넣은 이웃노드들이 들어있게 되는데, <br>
이 중에서 가장 F값이 작은 것을 찾아서 꺼내서 그 노드로 이동하면 된다. <br>
이전 노드는 ClosedList에 넣는다.

이 과정을 반복하다보면 **OpenList에는 내가 열어봤던 노드들이 차곡차곡 쌓여가고,** <br>
그 노드들 중에서 F값이 가장 작은 노드들로 점차 이동해나가는 로직이 완성이 된다. <br>
알고리즘을 정리하면 다음과 같다.

> 1. 처음 내 위치를 노드로 만들어서 OpenList에 넣는다.
2. OpenList에서 F값이 가장 작은 노드를 찾아서 꺼낸다.(이 때, Queue로 시간복잡도를 낮출 수 있다.)
3. 꺼낸 노드로 이동하고, 이전 노드를 ClosedList에 넣는다.
4. 이동한 노드의 이웃노드(상하좌우)를 생성해서 OpenList에 넣는다.(이미 탐색한 적이 있는 노드는 새로 생성x)
5. 2번부터 내용을 반복해서 타겟에 접근한다.
6. 타겟에 도달하면, 현재 노드의 부모 노드들을 타고 가면서 경로를 리스트화 시킨다.

이렇게 정리할 수 있을 것이다. 물론 말로는 쉽지만, 이를 코드화 하는 것이 꽤 어려운 작업이었다. <br>
하지만 2달 전만 하더라도 DFS와 BFS를 이용한 길찾기 코딩테스트도 풀지 못하던 것을 생각하면 <br>
엄청난 발전이라고 할 수 있다. 그리고 A스타를 직접 에러없이 구현을 하고나니, DFS와 BFS도 구현할 수 있겠다는 생각이 들었다.

만드는 과정중에는 알고리즘 구현하는 파트를 괜히 선택했다고 후회하기도 했지만, <br>
**직접 완성을 하고 나니 뿌듯하기도 하고 이 과정 중에 많은 것을 배우는 시간이 되어서 잘 선택했다고 생각이 들었다.**


#### 2) 이제 상태 패턴은 손쉽게 구현할 수 있다!

물론 말그대로 쉽게 구현을 할 수 있다는 것은 아니다... <br>
다만 그만큼 많이 구현을 해보다보니 형태와 원리가 익숙하면서 동작하는 구조가 머릿속에서 그려지기 시작했다. <br>

이번에 구현하게 되는 상태들은 몬스터가 지정된 위치를 **순찰**하고, 플레이어를 감지했을 때에 **추적**을 하며, <br>
추적하던 중에 플레이어를 놓치면 주변을 **탐색**하고 다시 순찰을 하는 AI를 만들어내는 것이다. <br>
이 과정에서 **순찰과 추적 단계에서 A스타로 경로탐색**하는 것을 사용하게 되었다.

확실히 이전 프로젝트들을 통해서 상태 패턴을 많이 경험했다보니, 상태 패턴 관련해서는 어려운 것이 없었다. <br>
여전히 어려움을 겪는 것은 **이동 관련 로직**이 발목을 잡았다. <br>

일단 순찰을 하기 위해서 **2개의 순찰 포인트**를 지정해주고 그 길을 A스타를 활용해서 경로를 찾는 것을 생각해냈다. <br>
순찰 포인트들은 고정이 되어 있기에 **처음에 몬스터가 생성 될 때만 A스타 1번으로 경로를 탐색하고 저장**해놓기로 했다. <br>
경로에 해당하는 각 타일들로 이동을 해야 하는데, 여기서 **부동 소수점**이 발목을 잡았다. <br>
벡터가 float값이어서 해당 타일에 왔을 때, 그 타일에 도달했다는 것을 Vector2값이 같다는 조건문으로 만들었는데, <br>
**정확한 지점을 찾지 못하고** 덜덜 떨리는 모습만 보였다.

이 문제를 해결한 것은 이동 방식을 바꿔서 해결했다. <br>
처음에 내가 이동 구현을 한 것은 Translate를 활용했던 것이 문제였다. <br>
이 **Translate는 특정 방향으로 이동**을 시키는 메서드였기에 **정확한 도착점을 명시하는 것이 거의 불가능하다.** <br>
그래서 특정 위치로 이동하도록 하는 MoveTowards를 사용해서 각 타일의 벡터로 정확히 이동시키는 것을 구현했다. <br>
**MoveTowards는 지정한 위치로 이동**하라는 메서드였기에 **도착점으로 정확히 이동시킬 수 있었던 것이다.**

이렇게 이동하는 방식에 대해 1가지 더 있음을 깨닫게 되었고, **AddForce와 velocity**등의 물리연산까지 필요한 이동, <br>
특정 방향으로 이동하게 하는 **Translate**와 특정 위치로 이동하게 하는 **MoveToawrds**까지 <br>
크게 3가지의 방식을 모두 기억해두고 적재적소에 맞는 것을 골라서 사용하도록 하자!

#### 3) 레이캐스트와 기즈모는 함께 사용하면 덜 헷갈린다..

이번에 LOS를 통해서 플레이어 감지를 하도록 알고리즘을 만들어야 했다. <br>
그래서 레이캐스트를 사용해서 만들 예정이었다. 하지만 기즈모는 생각하지 못했었다. <br>
기즈모 사용에 익숙하지 않았던 터라, 머릿 속으로 그려가면서 레이캐스트를 사용하려고 했는데 <br>
다음에는 **레이캐스트를 사용할 때에는 기즈모를 꼭 함께 사용하도록 해야겠다.**

일단 레이캐스트를 시각적으로 볼 수가 없다보니, 테스트를 하는데 많은 시간이 소요가 되었다. <br>
일일히 **레이캐스트가 닿는 것을 런타임 실험을 하면서 Debug를 확인**했어야 했다. 너무 힘들었다... <br>
특히, 순찰 중에 플레이어를 포착하는 것이 눈에 보이지 않아서 더 애를 먹었다.

순찰과 추적 상태를 구현하고 나서야, 탐색하는 것을 시각화 하기 위해 **기즈모를 사용해보았고 훨씬 이해하기 수월했다.** <br>
비록 **상태 패턴에서는 각 상태 클래스에는 MonoBehaviour가 없기 때문에, 기즈모를 우회하는 과정이 필요**하기는 하지만 <br>
처음에 상태 패턴을 구현할 때부터 대비해서 만들고, 작업이 끝나고 지운다면 크게 어렵지 않았을 것이다.

다음에 레이캐스트를 또 사용하게 되는 때가 올 텐데, 그 때에는 바로 기즈모까지 사용해서 손쉽게 <br>
레이캐스트를 사용하는 지혜로운 코딩을 하도록 해야겠다.

---

## 내용정리 블로그 링크




