# 2025-11-21 TIL

## 오늘 배운 내용
- Skill 클래스 대폭 수정
- 배틀 시스템 초기 작업 완료
- Unity에서의 생성자 사용 요령
- MonoBehaviour 없이 코루틴 발동시키기
- MonoBehaviour 없이 코루틴으로 업데이트 구현하기

## 느낀 점

### 1. 상속이 항상 답은 아니었구나...
이번 개인 프로젝트 과제가 시작이 되었다. 물론 이전부터 기획과 초기 작업들을 하고 있었기에 오늘은 추가적인 시스템 개선을 목적으로 작업을 진행했다.
<br>
이번 개인 프로젝트 게임으로는 **림버스 컴퍼니의 배틀 시스템 구현**을 진행하기로 했다.
<br>
이전 콘솔 프로젝트에서도 이와 비슷한 내용을 다루었지만, 그 때에는 코딩을 시작한지 이제 1달밖에 되지 않았던 시기였기에
<br>
비교적 규모도 작고 막히는 경우에 그 문제를 해결하는데도 어려움을 많이 겪다보니...게임이라고 하기엔 부족한 게 많았던 결과물이었다고 생각한다.
<br>
<br>
그래서 이번 개인 프로젝트는 이전의 콘솔 프로젝트의 내용을 더 보강해서 유니티로 직접 시스템을 가시적으로 구현해보기로 정했다.
<br>
림버스 컴퍼니의 배틀 시스템을 구현하기로 한 계기는 내가 평소에도 즐겨하고,
<br>
게임을 플레이하면서도 턴제임에도 독특한 전투 방식을 가지고 있기 때문에 시스템 구현을 하는 과정에서
<br>
 **많은 디자인 패턴 사용과 지식적인 공부**를 할 수 있을 것 같아 선택하였다.
<br>
<br>
오늘 진행한 내용을 이제 되짚어보자면...며칠 전부터 문제가 되었던 것이 다른 턴제 게임과 달리,
<br>
스킬 데미지 이전에 "합"이라는 것을 진행한다는 것이 가장 먼저 마주하게 된 문제점이었다.
<br>
<br>
합을 진행하기 위해선 플레이어 캐릭터와 에너미, 그리고 각각 사용하기로 한 스킬 1개씩이 필요했다.
<br>
이를 위해 유닛을 담는 리스트와 스킬을 담는 리스트를 만들고, 메서드를 만들었다.
<br>
<br>
그런데 문제가 발생한 것이 있었다...SO를 사용해서 스킬의 초기값을 보장하고,
<br>
ISkill이라는 인터페이스를 통해 현재 스킬들의 외부참조를 가능하게 하는 구조를 만들었지만
<br>
SO를 합을 진행하기 위한 스킬 리스트는 ISkill로 만들었을 때, 코드가 계속 부딪히는 현상이 발생했다.
<br>
<br>
이를 해결하기 위해 스킬 클래스들을 훑어보면서 하나 깨달은 것이 있었다.
<br>
스킬SO 스크립트를 다른 스킬들이 상속받아서 구현을 하다보니, **가독성은 떨어지고 코드 결합도는 올라가는 느낌**을 많이 받았다.
<br>
한 눈에 코드의 전체 구성이 눈에 들어오지 않고 SO스크립트와 스킬 클래스, 유닛 클래스를 번갈아가며 확인하게 되니
<br>
한 부분을 고치면 다른 데가 문제가 발생하는 연쇄적인 에러의 늪을 맞이 한 것이다...
<br>
<br>
그래서 여러 고민을 한 끝에 스킬 상속을 끊고 SO데이터는 직렬화로 받아서 사용하는 것으로 했다.
<br>
어차피 SO데이터값은 초기값으로 런타임 중에도 변화를 주지 않는 고정값으로 사용할 생각이었기에
<br>
굳이 상속을 고집할 필요가 없었고, 각각의 스킬들은 ISkill이라는 인터페이스로 공통되게 참조할 수 있기에 문제가 없었다.
<br>
상속을 끊고 스킬을 다른 클래스에서 참조할 수 있는 방법은 ISkill 하나 뿐이기 때문에,
<br>
일관되게 다른 클래스에서 참조하게 되었고 그 과정에서 **스킬 생성자를 통해서 플레이어에게 스킬을 들고 있게 하는 방법**도 익힐 수 있었다.
<br>
<br>
유니티에 들어오고 나서는 이 생성자를 사용하는 것이 어색하면서도, GetComponent와 혼동 되는 경우도 많았는데
<br>
쉽게 생각하면 **new는 MonoBehaviour가 없는 클래스를 다른 클래스에 연결할 때 사용**하기 용이하다는 것을 기억하면 되었다.

### 2. 코루틴 접근을 매니저에서 받아서 할 수 있다니!?

스킬 클래스를 정리하고 나니, 합 시스템과 데미지 시스템도 손쉽게 만들 수 있었는데
<br>
가장 인상깊었던 것은 스킬 모션을 발동하려고 할 때, **코루틴을 활용**하는 것이었다.
<br>
**스킬의 각 발동 모션들을 상태 패턴**으로 정의를 해놓고 이 모션들을 시간지연을 하면서
<br>
스킬 모션을 진행하려 했고, 그 과정에서 코루틴의 발동이 필요했다.
<br>
<br>
하지만 코루틴을 사용하려고 해도 IEnumerator까지는 MonoBehaviour 없이 사용 가능했지만,
<br>
**StartCoroutine은 MonoBehaviour없이 사용이 안 되었다.** 그래서 MonoBehaviour을 상태마다 상속을 시켜줄까 고민도 했지만
<br>
코루틴 하나 때문에 MonoBehaviour을 상속하는 건 피하고 싶었다.
<br>
이전에 강사님께서 성능적인 차이도 발생할 수 있다고도 말씀하셨고,
<br>
상태 패턴의 의의가 퇴색될 것 같았고 다른 방법을 생각할 필요가 있었다.
<br>
<br>
그래서 전역적인 접근이 가능한 매니저를 활용해보면 어떨지 생각이 들었다.
<br>
개인 프로젝트 전에 팀 프로젝트에서 글로벌 영역을 담당하면서 게임매니저 관련 공부를 많이 했다보니,
<br>
전역적으로 접근이 가능한 매니저 시스템을 사용하는 것에 익숙했었고,
<br>
마침 전투를 담당하는 배틀 매니저 구성도 되어 있어서 **전역 접근으로 코루틴을 전달**해보기로 했다.
<br>
<br>
결과적으로 **배틀 매니저에서 StartCoroutine을 발동하는 메서드를 만들고 각 스킬의 상태들은 매니저에 접근해서 StartCoroutine을 사용**하게 했다.
<br>
추가적으로 상태패턴을 호출하는 클래스에서도 업데이트를 코루틴으로 받아서 임시로 구현할 수 있다는 사실도 알 수 있었다.
<br>
스킬 관련 클래스에는 MonoBehaviour은 하나도 없기에 여기서도 **전역적으로 코루틴을 실행해주고 yield return에 null을 사용**해서 임시로 Update를 구현했다.
<br>
이후에 2D에셋을 구해서 스프라이트 사용방식도 익히면서 오늘의 일과를 마쳤다.

### 3. 마치며..

오늘 하루 시간 투자에 비해 많은 결과물을 만들지는 못했다고 생각한다.
<br>
하지만 코드 리팩토링과 코루틴 발동 방식을 생각해내면서 많은 내용을 공부할 수 있었다고 느꼈다.
<br>
이전 팀프로젝트 시작할 당시에는 다른 훈련생들에 비해 턱없이 떨어지는 실력을 가졌다고만 느꼈지만,
<br>
팀프로젝트를 진행하며 나만 어렵고 힘들어하는 것이 아님을 깨달은 후로는
<br>
더 노력하고 공부하고 있는 나 자신을 보며 뿌듯하게 느끼고 있다.
<br>
<br>
개인 프로젝트가 본격적으로 시작이 된 오늘 나는 더 잘 할 수 있다는 자신감으로 시작한 것 같다.
<br>
**기억하자! 나는 이제 프로그래밍을 배운지 3개월밖에 안 된 뉴비중에 뉴비라고!**
<br>
앞으로 남은 길은 폭풍성장의 길밖에 남지 않았다!
<br>

### 화이팅!!!!!!!

---

## 내용정리 블로그 링크




